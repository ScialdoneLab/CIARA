---
title: "GapClust_human_gastrula"
author: "Gabriele Lubatti"
date: "7/20/2022"
output: html_document
---

```{r }
library(Seurat) 
library(rflann) 
library(irlba) 
library(e1071)
```


```{r }
find_elbow <- function(x, y){
  n <- length(x)
  firstPoint <- c(x[1], y[1])
  lineVec = c(x[n]-x[1], y[n]-y[1])
  lineVecNorm = lineVec/(sqrt(sum(lineVec^2)))
  vecFromFirst = cbind(x-x[1], y-y[1])
  scalaProd =rowSums(vecFromFirst * cbind(rep(lineVecNorm[1], n), rep(lineVecNorm[2], n)))
  vecFromFirstParallel = outer(scalaProd, lineVecNorm)
  vecToLine = vecFromFirst - vecFromFirstParallel
  distToLine = sqrt(rowSums(vecToLine^2))
  idx = which.max(distToLine)
  return(x[idx])
}
```

```{r }

GapClust <- function(data, k=200){

  ## Fano genes for clustering
  pbmc <- CreateSeuratObject(counts = data)
  pbmc <- FindVariableFeatures(object = pbmc, selection.method='vst', nfeatures=dim(data)[1], verbose = F)
  vst <- (pbmc@assays$RNA@meta.features$vst.variance.standardized)
  den <- density(vst)
  features.vst <- dimnames(data)[[1]][vst > find_elbow(den$x[which.max(den$y):length(den$x)], den$y[which.max(den$y):length(den$y)])]
  tmp <- data[dimnames(data)[[1]] %in% (features.vst),]
  tmp <- log2(as.matrix(tmp)+1)
  pca <- irlba(t(tmp), nv=min(c(50, dim(tmp)-1))) # More robust no error, contrast to calcul.pca
  pca$pca <-t(pca$d*t(pca$u))
  knn.res <- Neighbour(pca$pca, pca$pca, k=k)

  distance.diff <- (knn.res$distances[, -1, drop = FALSE] - knn.res$distances[, -ncol(knn.res$distances), drop = FALSE])
  diff.left <- distance.diff[, -1, drop = FALSE] - distance.diff[, -ncol(distance.diff), drop = FALSE]
  diff.both <- diff.left[, -ncol(diff.left), drop=FALSE] - diff.left[, -1, drop=FALSE]
  diff.both[,1] <- diff.both[,1] + distance.diff[,1]  # Very important due to distance variation to the first neighbor.

  v1.k <- matrix(NA, dim(data)[2], k-3)
  skew <- c()
  top.values.ave <- c()
  for(j in 1:dim(diff.both)[2]){
    v <- diff.both[,j]
    v1 <- v
    for(m in 1:length(v)){
      v1[m] <- (v[m] + v[knn.res$indices[m,2]])/2
    }
    v1.k[, j] <- (v1)
    v2 <- v1[order(v1, decreasing = T)[(j+2):length(v1)]]
    v2[is.na(v2)] <- 0
    top.values <- v1[knn.res$indices[which.max(v1),1:(j+1)]]
    v2 <- c(v2[v2 <= (quantile(v2, 0.75)+1.5*IQR(v2)) & v2 >= (quantile(v2, 0.25)-1.5*IQR(v2))], rep(sum(top.values[top.values>0])/length(top.values), (2)))
    skew <- c(skew, skewness(v2))
    top.values.ave <- c(top.values.ave, mean(top.values))
  }

  ids <- which(skew > 2)
  col.mat <- matrix(0, length(ids), dim(tmp)[2])
  for(i in 1:length(ids)){
    top.cell <- which.max(v1.k[,(ids[i])])
    col.mat[i, knn.res$indices[top.cell,1:(ids[i]+1)]] <- skew[ids[i]] * top.values.ave[ids[i]]
  }

  id.max <- apply(col.mat, 2, which.max)
  max.val <- apply(col.mat, 2, max)
  id.max[max.val==0] <- 0
  cnt <- table(id.max)
  cnt <- cnt[names(cnt)!='0']
  id.max.match <- cnt[which(cnt == (ids[as.integer(names(cnt))] + 1))] - 1

  cls <- rep(0, dim(tmp)[2])
  for(id.match in id.max.match){
    cls[id.max==(id.match)] <- which(id.max.match %in% id.match)
  }

  rare.cells <- list()
  for(id.match in id.max.match){
    rare.cells[[as.character(id.match)]] <- knn.res$indices[which.max(v1.k[,id.match]), 1:(id.match+1)]
  }
  results <- list(skewness=skew, rare_cell_indices=rare.cells, rare_score=v1.k)
  return(results)
}

```


```{r }
setwd(paste0(current_wd,"/CIARA"))
load(file = "raw_counts_human_data.Rda")
load(system.file("extdata", "result.Rda", package = "CIARA"))
ciara_genes <- row.names(result)[result[, 1] < 1]
ciara_genes_top <- row.names(result)[order(as.numeric(result[, 1]))]
background=row.names(result)
meta_info <- readRDS(system.file("extdata", "annot_umap.rds", package ="CIARA"))
coordinate_umap <- meta_info[,2:3]

```

```{r }
elmir_seurat_ciara=cluster_analysis_integrate_rare(raw_counts_human_data,"Elmir data",0.01,5,30,ciara_genes)

```




```{r }

norm_elmir_ciara_5_30=as.matrix(GetAssayData(elmir_seurat_ciara, slot = "data",assay="RNA"))

```

```{r }
output=GapClust(norm_elmir_ciara_5_30)
```


